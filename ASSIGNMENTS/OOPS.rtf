{\rtf1\ansi\ansicpg1252\deff0\nouicompat\deflang1033{\fonttbl{\f0\fnil\fcharset0 Calibri;}}
{\colortbl ;\red255\green0\blue0;\red0\green77\blue187;\red0\green0\blue0;}
{\*\generator Riched20 10.0.21996}\viewkind4\uc1 
\pard\sa200\sl276\slmult1\cf1\kerning24\ul\b\f0\fs160\lang16393\par
\cf2\ulnone       OOPS\cf1\ul\par
\fs80\par
B1 What Is class in Object Oriented Programming Language?\ulnone\b0\line\~\line\cf3\b\i In object-oriented programming, a class is a blueprint or template for creating objects. It defines the properties and behaviors that the objects of the class will have. For example, you could define a class for a car, which might include properties like the make, model, and year, as well as behaviors like accelerating and braking. You could then create multiple objects of the class "car," each with its own specific values for the properties. The objects are also known as instances of the class.\b0\i0\line\b\i\~\b0\i0\line\b\i Classes are a fundamental concept in object-oriented programming languages, and they are used to represent real-world objects and concepts in a program. They allow you to define the characteristics and behaviors of those objects in a structured way, and to create and manipulate objects based on those definitions\b0\i0 .\line\~\line\~\line\cf1\ul\b B2 What is an Object in Object Oriented Programming Language?\ulnone\b0\line\~\line\cf3\b\i In object-oriented programming (OOP), an object is a self-contained entity that represents a specific instance of a class. It combines data and behavior, and encapsulates both within a single unit. Objects are created from classes, which are templates or blueprints for creating objects.\b0\i0\line\b\i An object has various characteristics, which are referred to as its attributes. These attributes can be either data or behavior. Data attributes represent the object's state, while behavior attributes represent the actions that the object can take.\b0\i0\line\b\i For example, consider a class called "Person" that represents a person. It might have attributes such as name, age, and occupation. These attributes would represent the state of the object. The class might also have behavior attributes such as "speak", which would represent the action of the person speaking.\b0\i0\line\b\i To create an object from a class, you would use the class as a template to instantiate a specific instance of the class. This process is called instantiation. Once an object has been instantiated, you can access and modify its attributes, and invoke its behavior attributes to make the object take certain actions.\b0\i0\line\b\i Overall, an object in OOP is a self-contained unit that combines data and behavior, and represents a specific instance of a class. It is a key concept in OOP, and is used to model real-world entities and their interactions within a program.\b0\i0\line\b\i\~\b0\i0\line\cf1\ul\b B3 WhatI s Difference Between Class And Interface?\ulnone\b0\line\~\line\cf3\b\i In object-oriented programming (OOP), a class is a template or blueprint for creating objects. It defines the data and behavior that an object can have, and serves as a blueprint for creating specific instances of the class, which are called objects.\b0\i0\line\b\i An interface, on the other hand, is a purely abstract class that defines a set of methods that a class must implement. An interface does not contain any implementation details for these methods \endash  it only specifies the method names, return types, and parameters.\b0\i0\line\b\i There are several key differences between classes and interfaces:\b0\i0\line\b\i Implementation: A class provides an implementation for the methods defined in an interface, while an interface only defines the methods without providing an implementation.\b0\i0\line\b\i Inheritance: A class can inherit from another class or interface, while an interface can only inherit from other interfaces.\b0\i0\line\b\i Multiple inheritance: A class can only inherit from a single class, but it can implement multiple interfaces. This is known as multiple inheritance.\b0\i0\line\b\i Accessibility: The methods in a class can have different levels of accessibility (e.g., public, private, protected), while the methods in an interface are always public.\b0\i0\line\b\i In summary, a class is a template for creating objects that defines both data and behavior, while an interface is a purely abstract class that defines a set of methods that a class must implement. Classes and interfaces are both important concepts in OOP, and are used in different ways to achieve encapsulation and abstraction.\b0\i0\line\b\i\~\b0\i0\line\cf1\ul\b\i B4 What Is Method Overloading in Object Oriented Programming Language?\ulnone\b0\i0\line\cf3\b\i Method overloading in object-oriented programming (OOP) is a technique for creating multiple methods with the same name, but with different parameter lists. This allows a class to have multiple methods that can be called with the same name, but that perform different tasks depending on the number and type of arguments passed to the method.\b0\i0\line\b\i Here's an example of method overloading in Java:\b0\i0\line\b\i public class Calculator \{ public int add(int a, int b) \{ return a + b; \}\b0\i0\line\b\i  public double add(double a, double b) \{ return a + b; \} \} \b0\i0\line\b\i In this example, the Calculator class has two methods called add, but each method has a different parameter list. The first add method takes two integers as arguments and returns their sum. The second add method takes two doubles as arguments and returns their sum.\b0\i0\line\b\i Method overloading is a useful feature in OOP because it allows you to write more concise and flexible code. It can also improve the readability of your code, as it allows you to use a single method name for a variety of different tasks.\b0\i0\line\b\i There are some rules and limitations to method overloading that you should be aware of, such as:\b0\i0\line\b\i The methods must have different parameter lists.\b0\i0\line\b\i The methods can have different return types, but this is not considered to be part of the method's signature.\b0\i0\line\b\i You cannot overload a method based on just the return type.\b0\i0\line\b\i You cannot overload a method by changing the access modifier or the exception list.\b0\i0\line\b\i Method overloading is an important concept in OOP, and is used in many programming languages including Java, C++, and C#.\b0\i0\line\b\i  \b0\i0\line\cf1\ul\b B5 What Is Data hiding in Object Oriented Programming Language?\ulnone\b0\line\b\~\b0\line\cf3\b\i Data hiding is a principle in object-oriented programming (OOP) that refers to the practice of protecting the internal data of a class from being directly accessed or modified by external code. It is a way of encapsulating the data of an object and limiting the scope of its visibility, so that the data can only be accessed or modified through the class's defined methods.\b0\i0\line\b\i Data hiding is an important concept in OOP because it promotes the idea of modularity and separation of concerns. It allows you to design your classes in a way that separates the internal implementation details from the external interface, which makes your code more modular and easier to maintain.\b0\i0\line\b\i There are several ways to implement data hiding in OOP:\b0\i0\line\b\i Access modifiers: Most OOP languages provide access modifiers (e.g., public, private, protected) that allow you to control the visibility of class members (e.g., fields, methods). By default, class members are usually private, which means that they can only be accessed within the class itself.\b0\i0\line\b\i Getters and setters: You can define "getter" and "setter" methods in your class to allow external code to access or modify the internal data of the class. These methods are usually public, which means that they can be accessed from outside the class.\b0\i0\line\b\i Encapsulation: Data hiding can be achieved through the principle of encapsulation, which refers to the bundling of data and behavior together within a single unit (i.e., an object). Encapsulation allows you to hide the internal implementation details of an object from external code, while still providing a way to access and modify the object's data through its defined methods.\b0\i0\line\b\i Data hiding is a key concept in OOP, and is used to improve the modularity and maintainability of your code by encapsulating the data of an object and limiting its scope of visibility.\b0\i0\line\b\i\~\b0\i0\line\b\i\~\b0\i0\line\cf1\ul\b\i B6 What are the differences between abstract classes and interface.?\ulnone\b0\line\cf3\i0\~\line\b Abstract classes and interfaces are two key concepts in object-oriented programming (OOP) that allow you to create abstractions and define common behavior for classes. However, there are several important differences between abstract classes and interfaces that you should be aware of:\b0\line\b Implementation: An abstract class can contain both abstract methods (methods without an implementation) and concrete methods (methods with an implementation), while an interface can only contain abstract methods. This means that an abstract class can provide some implementation details, while an interface cannot.\b0\line\b Inheritance: An abstract class can be inherited by another class using the extends keyword, while an interface can be implemented by a class using the implements keyword. A class can only inherit from a single abstract class, but it can implement multiple interfaces. This is known as multiple inheritance.\b0\line\b Accessibility: The methods in an abstract class can have different levels of accessibility (e.g., public, private, protected), while the methods in an interface are always public.\b0\line\b Purpose: Abstract classes are typically used to define a common interface and provide some implementation details for a group of related classes, while interfaces are used to define a pure abstraction and specify a set of methods that a class must implement.\b0\line\b In summary, abstract classes and interfaces are both used to define abstractions and create common behavior for classes, but they have different purposes and use cases. Abstract classes can contain both abstract and concrete methods, and are typically used to define a common interface and provide some implementation details for a group of related classes. Interfaces, on the other hand, can only contain abstract methods and are used to define a pure abstraction and specify a set of methods that a class must implementt.\par
\cf1\ul B7 What aretheVirtualFunc on inObjectOrientedProgramming?\par
\cf3\par
\ulnone\i in object-oriented programming, a virtual function is a member function that can be redefined in derived classes. When you call a virtual function from an object, the function that is executed is the one defined in the most derived class that contains a definition for that function. This allows you to create a base class with a set of functions that can be overridden by derived classes to provide more specialized behavior.\par
\par
The virtual keyword is used to declare a virtual function in the base class. Derived classes can then override the virtual function by using the same function signature and the keyword "override".\par
\par
Here is an example in C++:\par
\par
\par
class Shape \{\par
 public:\par
  virtual void draw() \{\par
    // Default implementation of draw function\par
  \}\par
\};\par
\par
class Circle : public Shape \{\par
 public:\par
  void draw() override \{\par
    // Specialized implementation of draw function for circles\par
  \}\par
\};\par
In this example, the Shape class has a virtual function called draw, which can be overridden by derived classes. The Circle class derives from Shape and provides its own implementation of the draw function. When you call draw on an object of type Circle, the version of draw defined in the Circle class will be executed.\par
\par
\cf1\ul B8 What is Constructorin Object Oriented Programming ?\par
\cf3\ulnone\par
In object-oriented programming, a constructor is a special type of method that is called when an object is created from a class. It is used to initialize the object's properties and perform any other setup that is required before the object is used.\par
\par
In most programming languages, the constructor is given the same name as the class, and it does not have a return type. When you create an object from a class, you call the constructor to create an instance of the object.\par
\par
Here is an example of a simple class with a constructor in Python:\par
\par
Copy code\par
class Car:\par
  def __init__(self, make, model):\par
    self.make = make\par
    self.model = model\par
\par
my_car = Car('Ford', 'Mustang')\par
In this example, the Car class has a constructor that takes two arguments: make and model. When the my_car object is created, the constructor is called with the values 'Ford' and 'Mustang', which are used to initialize the make and model properties of the object.\par
\cf1\ul\i0 B9 What is Abstract class in Object Oriented Programming?\par
\cf3\ulnone\i\par
An abstract class is a class that cannot be instantiated, but can be subclassed. It is a way to create a base class that provides a common interface and implementation details, which can be shared among multiple derived classes.\par
\par
An abstract class is defined using the abstract keyword, and it usually contains one or more abstract methods. An abstract method is a method that is declared in the abstract class, but does not have an implementation. Subclasses of the abstract class are required to provide an implementation for the abstract methods.\par
\par
Abstract classes are useful when you want to define a base class that provides common functionality, but you want to leave some details to be implemented by the derived classes. This allows you to create a flexible and extensible design, where you can add new derived classes that reuse the common functionality of the base class, but can also customize and extend it as needed.\par
\cf1\ul\i0 B10 What is Final Keyword in Object Oriented Programming?\par
\cf3\ulnone\i\par
In object-oriented programming languages, the "final" keyword is used to indicate that a particular class or member function cannot be inherited or overridden by derived classes.\par
\par
For example, in C++, you can use the "final" keyword when declaring a class to indicate that the class cannot be used as a base class:\par
\par
Copy code\par
class Base final \{\par
  // Class definition\par
\};\par
\par
class Derived : public Base \{\par
  // Error: Cannot derive from a final class\par
\};\par
You can also use the "final" keyword when declaring a virtual function to indicate that the function cannot be overridden by derived classes:\par
\par
Copy code\par
class Base \{\par
 public:\par
  virtual void foo() final \{\par
    // Function implementation\par
  \}\par
\};\par
\par
class Derived : public Base \{\par
 public:\par
  void foo() \{\par
    // Error: Cannot override a final function\par
  \}\par
\};\par
The "final" keyword can be used to help ensure that the behavior of a class or function is not changed by derived classes, which can be useful for maintaining the integrity of the base class. It can also be used to improve performance by allowing the compiler to generate more efficient code, since it knows that the function cannot be overridden.\par
\cf1\ul\i0\fs72 B11 What is Pure Virtual funtion in Object Oriented Programming?\par
\cf3\ulnone\i\fs80 In object-oriented programming, a pure virtual function (also called an abstract function) is a virtual function that has no implementation in the base class. A class that contains a pure virtual function is called an abstract class. An abstract class cannot be instantiated, and it serves as a base class for other classes that can be instantiated.\par
\par
A pure virtual function is declared by setting its implementation equal to zero in the class declaration, like so:\par
\par
Copy code\par
class Shape \{\par
public:\par
    virtual void draw() = 0;\par
\};\par
A class that inherits from an abstract class must provide an implementation for all of its pure virtual functions. If it doesn't, then that class will also be considered abstract and cannot be instantiated.\par
\par
Copy code\par
class Rectangle : public Shape \{\par
public:\par
    void draw() \{ /*implementation */\}\par
\};\par
By doing this, it ensures that the derived class is guaranteed to have a certain set of methods, even if they don't have any implementation in the abstract base class.\par
\par
The main purpose of Pure virtual function is for creating interfaces.\par
\par
\cf1\ul\i0\fs96 B12 What are Sealed Modifiering ObjectOriented Programming?\par
\par
\cf0\ulnone\i In object-oriented programming, the "sealed" modifier is used to indicate that a class or method cannot be inherited by any other class. A sealed class cannot be used as a base class for any other class, and a sealed method cannot be overridden by any derived class.\par
\par
A sealed class is defined by applying the "sealed" keyword before the class declaration. For example:\par
\par
Copy code\par
sealed class MySealedClass \{\par
    // class members\par
\}\par
A sealed method is defined by applying the "sealed" keyword before the method declaration inside a class\par
\par
Copy code\par
class MyClass \{\par
   sealed void MyMethod() \{\par
      // Method implementation\par
   \}\par
\}\par
The main purpose of sealed classes and methods is to prevent unintended and incorrect behavior that can occur when a derived class modifies the behavior of the base class in an unexpected way.\par
It can also increase performance by removing the virtual call to a method, when the method is defined as sealed.\par
It can be used along with override keyword to indicate that the method can be override only by the derived class of this class.\par
\par
\cf1\ul B13 What is Dynamic orrun time Polymorphismin oops ?\i0\par
\cf3\ulnone\i\fs80\par
In object-oriented programming, polymorphism is the ability of an object or function to take on multiple forms. There are two main types of polymorphism: static (or compile-time) polymorphism and dynamic (or runtime) polymorphism.\par
\par
Static polymorphism is achieved through function overloading and operator overloading, which allows multiple methods or operators to have the same name but different parameter lists. These methods are resolved at compile time based on the types of the arguments passed to them.\par
\par
Dynamic polymorphism, on the other hand, is achieved through virtual functions. In a class hierarchy, a virtual function is a member function that is declared as "virtual" in the base class and can be overridden in derived classes. When a virtual function is called through a base class pointer or reference, the program will determine at runtime which version of the function to execute, based on the actual type of the object pointed to or referred to.\par
\par
An example of dynamic polymorphism:\par
\par
Copy code\par
class Shape \{\par
public:\par
    virtual void draw() = 0;\par
\};\par
\par
class Rectangle : public Shape \{\par
public:\par
    void draw() \{ /* draw a rectangle */ \}\par
\};\par
\par
class Circle : public Shape \{\par
public:\par
    void draw() \{ /* draw a circle */ \}\par
\};\par
\par
int main() \{\par
    Shape* shape1 = new Rectangle;\par
    Shape* shape2 = new Circle;\par
    shape1->draw(); // calls Rectangle::draw()\par
    shape2->draw(); // calls Circle::draw()\par
    return 0;\par
\}\par
Here, draw() function is a virtual function, so the program will determine at runtime which version of the function to execute, based on the actual type of the object pointed to. In this case, it will call the implementation of draw() from the derived class of the object pointed by shape1 and shape2, respectively.\par
\par
Dynamic Polymorphism is a run time process, the decision of which function to call is based on the runtime object, not compile-time.\par
\par
\cf1\ul\i0 B14 What is Access Modifiering Object Oriented Programminng ?\par
\par
\cf0\ulnone\i In object-oriented programming, access modifiers are used to control the level of access that other classes or functions have to the members (variables, properties, and methods) of a class. The three main types of access modifiers are:\par
\par
Public: Members with public access can be accessed from anywhere, both inside and outside the class. This is the default access level for class members.\par
\par
Protected: Members with protected access can be accessed within the class itself and by any derived classes, but not by other classes or functions outside the class or derived class.\par
\par
Private: Members with private access can only be accessed within the class itself, and not by any derived classes or other classes or functions outside the class.\par
\par
For example:\par
\par
Copy code\par
class MyClass \{\par
public:\par
    int x;\par
protected:\par
    int y;\par
private:\par
    int z;\par
\};\par
Here, x is a public member, y is a protected member, and z is a private member. Any part of the program can access x, but only the members and the derived class of MyClass can access y, and z can only be accessed within MyClass.\par
\par
Access modifiers help to encapsulate the internal state and behavior of a class, making it more robust and maintainable by hiding implementation details and restricting access to certain members. It also prevents unwanted modification or access by other code.\par
\i0\par
\cf1\ul B15 What is Friend Function in Object Oriented Programming?\par
\cf0\ulnone\i In object-oriented programming, a friend function, also called a friend method or simply a friend, is a function that is defined outside a class's scope, but has the ability to access the private and protected members of the class in which it is declared as a friend. This is done by using the "friend" keyword in the class declaration.\par
Friend functions are not considered as member functions of the class, but they can be thought of as having an exceptional access level to the class's members.\par
\cf1\ul\i0 B16 What is Overloading in Object Oriented Programming\par
\cf0\ulnone\i In object-oriented programming, overloading refers to the ability of a class or a function to have multiple definitions with the same name but with different parameters. This allows you to use the same method or operator name in different ways, depending on the context in which it is used.\par
\par
There are two types of overloading in C++:\par
\par
Function overloading: Also known as "compile-time polymorphism", function overloading allows you to have multiple methods with the same name but different parameter lists. When a method is called, the compiler will select the appropriate method based on the types and number of arguments passed in the call.\par
For example:\par
\par
Copy code\par
class MyClass \{\par
    void print(int x) \{ cout << x; \}\par
    void print(double x) \{ cout << x; \}\par
\};\par
Operator overloading: Operator overloading allows you to define the behavior of operators (such as +, -, *, /) for user-defined types (such as classes or structs). This allows you to use the same operator with user-defined types in the same way as with built-in types.\par
Copy code\par
class MyClass \{\par
    int x;\par
    MyClass operator+(MyClass obj) \{\par
        MyClass res;\par
        res.x = x + obj.x;\par
        return res;\par
    \}\par
\};\par
Here operator '+' is overloaded for MyClass type so we can use the same '+' operator like int and double\par
\par
Overloading allows you to write more expressive and readable code, by using familiar and natural-looking operations in different contexts. The overloaded methods or operators can be useful to provide alternative ways of using the same function/operator.\par
\cf1\ul\i0 B17 What is the role of mutable storage class specifier?\par
\cf0\ulnone\i\par
In C++, the "mutable" storage class specifier is used to indicate that the value of a class member can be modified even if the containing object is declared as const. This allows you to modify the value of a member variable even if the object itself is declared as const.\par
\par
The mutable keyword is used when declaring a class member variable. For example:\par
\par
Copy code\par
class MyClass \{\par
    mutable int x;\par
public:\par
    void set_x(int value) const \{\par
        x = value;\par
    \}\par
\};\par
Here, even if the object of MyClass is declared as const, the value of x can still be modified using the set_x() method.\par
\par
The main use of mutable is to make some data member modifiable, even when the object is const.\par
It's a way to keep the const correctness of your class and at the same time allow the internal state to change for some members.\par
A good example for the use of mutable can be a cached value that is held by a class, It should be marked as mutable so it can be updated.\par
\par
It's important to note that mutable does not change the access level of a class member, it just makes it modifiable even when the object is const.\par
This means that a mutable member is still accessible just as any other member, but it can be modified even if the object is declared const.\par
\par
\par
\par
\par
\par
\cf1\ul\par
}
 